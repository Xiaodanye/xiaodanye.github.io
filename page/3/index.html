<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Xiaodanye</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="My Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiaodanye">
<meta property="og:url" content="http://xiaodanye.github.io/page/3/index.html">
<meta property="og:site_name" content="Xiaodanye">
<meta property="og:description" content="My Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaodanye">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Xiaodanye" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xiaodanye</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaodanye.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS项目优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2022-05-21T11:29:37.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/">JS项目优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="项目性能优化"><a href="#项目性能优化" class="headerlink" title="项目性能优化"></a>项目性能优化</h3><p>前端性能优化主要有七种方法，包括减少请求数量、减少资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和webpack优化。</p>
<p><strong>减少请求数量</strong>：图片处理、减少重定向、使用http缓存、不使用css@import、避免使用空的src和href</p>
<p><strong>减少资源大小</strong>：去除 SourceMap、gzip 压缩、CDN减少打包体积</p>
<p><strong>优化网络连接</strong>：使用CDN、使用DNS预解析、持久连接</p>
<p><strong>优化资源加载</strong>：资源加载位置、资源加载时机</p>
<p><strong>webpack性能优化</strong>：打包公共代码、动态导入和按需加载、删除无用的代码、长缓存优化、公共代码内联</p>
<p><strong>性能更好的API</strong></p>
<p><strong>减少重绘回流</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/" data-id="cl3jwbhw3000uaw5j2r5shjyo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS内存泄漏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" class="article-date">
  <time datetime="2022-05-21T11:29:07.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">JS内存泄漏</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>在JavaScript中，当我们创建变量、函数或任何你能想到的东西时，JS引擎会为此分配内存，并在不再需要时释放它。PS：内存管理上下文中的“对象”不仅包括JS对象，还包括函数和函数作用域。</p>
<p>JavaScript引擎有两个地方可以存储数据：内存堆和栈。堆和栈是引擎用于不同目的的两种数据结构。</p>
<p><strong>栈</strong>是JavaScript用来存储静态数据的数据结构。静态数据是引擎在编译时知道大小的数据。在JavaScript中，这包括原始值（字符串、数字、布尔值、未定义和null）和指向对象和函数的引用。</p>
<p><strong>堆</strong>是JavaScript用来存储动态数据的数据结构，动态数据是引擎在运行时根据需要分配空间。在JavaScript中，这包括对象和函数。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>JavaScript的垃圾回收机制是是一种自动的内存管理机制，为了防止内存泄漏（已经不需要的某一块内存还一直存在着）。垃圾回收就是找出不再使用的变量，然后释放掉其占用的内存。</p>
<p><strong>垃圾回收方式</strong></p>
<ol>
<li><p>标记清除（主要）</p>
<p>标记清除的主要概念是可达性。浏览器中的根是window对象，定期的，垃圾回收器将从这个对象开始，将不可访问的对象标记为垃圾，然后对其进行清理（收集）。</p>
</li>
<li><p>引用计数</p>
<p>引用计数的机制就是跟踪某一个值得引用次数，当声明一个变量并且将一个引用类型赋值给变量得时候引用次数加1，当这个变量指向其他一个时引用次数减1，当为0时触发回收机制进行回收。（循环引用问题）</p>
</li>
</ol>
<h4 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>内存泄漏（Memory leak）指的是当不再用到的对象内存，没有及时被回收。</p>
<p><strong>原因</strong></p>
<ol>
<li><p>意外的全局变量：在浏览器的JavaScript中，如果省略var、const或let，变量将附加到window对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  x = <span class="string">&#x27;未使用var声明，将自动创建全局变量&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">y</span> = <span class="string">&#x27;默认this将绑定到全局变量&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>被遗忘的定时器和回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// everything used in here can&#x27;t be collected</span></span><br><span class="line">  <span class="comment">// until the interval is cleared</span></span><br><span class="line">  <span class="title function_">doSomething</span>(object);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器（正确的情况下）</span></span><br><span class="line"><span class="built_in">clearInterval</span>(intervalId);</span><br></pre></td></tr></table></figure></li>
<li><p>不正当的闭包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">closure</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = <span class="title function_">closure</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 清除闭包（正确的情况下）</span></span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>DOM外引用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> root = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ul&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> li3 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#li3&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  root.<span class="title function_">removeChild</span>(ul); <span class="comment">// 由于ul变量存在，整个ul及其子元素都不能回收</span></span></span><br><span class="line"><span class="language-javascript">  ul = <span class="literal">null</span>; <span class="comment">// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被回收</span></span></span><br><span class="line"><span class="language-javascript">  li3 = <span class="literal">null</span>; <span class="comment">// 已无变量引用，此时可以回收</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" data-id="cl3jwbhvo000caw5je8or6n7d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS防抖与节流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" class="article-date">
  <time datetime="2022-05-21T11:28:31.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">JS防抖与节流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="防抖-amp-节流"><a href="#防抖-amp-节流" class="headerlink" title="防抖 &amp; 节流"></a>防抖 &amp; 节流</h3><h4 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a><strong>防抖(debounce)</strong></h4><p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***   防抖(debounce)   ***/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout; <span class="comment">// 闭包 私有化变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>, args = <span class="variable language_">arguments</span>; <span class="comment">// context：绑定this；args：接收传入参数</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// 清除计时</span></span><br><span class="line"></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 重新计时</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
<h4 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a><strong>节流(throttle)</strong></h4><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***   节流(throttle)   ***/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout; <span class="comment">// 闭包 私有化变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>, args = <span class="variable language_">arguments</span>; <span class="comment">// context：绑定this；args：接收传入参数</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123; <span class="comment">// 如果timeout为假，说明值为 undefined | null，可以触发</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>; <span class="comment">// 清除 变量</span></span><br><span class="line">        fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
<p><strong>总结</strong>：函数节流与函数防抖都是为了限制函数的执行频次，都是一种性能优化的方法。区别是防抖是有条件的周期性动作，而节流是无条件的周期性动作。对于防抖和节流一个最主观的判断方法就是：在10s内你疯狂点击一个按钮，如果使用了防抖则会只执行一次，而你使用了节流则会每隔一段时间执行一次，这个时间可以自己来掌控。</p>
<p>PS：函数节流与函数防抖的实现细节：</p>
<ol>
<li>外部函数中都定义了一个私有化变量timeout，这也是使用<strong>闭包</strong>的原因</li>
<li>闭包中重新定义了context、args，这是为了避免修改 this 指向和默认参数</li>
<li>二者都有对应的立即执行版本：触发事件后函数会立即执行，主要依据是对timeout的判断。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" data-id="cl3jwbhw2000taw5jdai25lem" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS同步与异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2022-05-21T11:28:00.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/">JS同步与异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步 &amp; 异步"></a>同步 &amp; 异步</h3><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的<strong>执行环境</strong>（context），又叫执行上下文。这个执行环境中存在着这个方法的作用域链以及this对象。其中，不同的变量存于内存中的不同位置：堆里存放着一些对象，而栈中则存放着一些基础类型变量以及对象的指针（上下文）。</p>
<p>当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为<strong>执行栈</strong>。</p>
<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始<strong>顺序执行</strong>。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境……这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>
<h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码，如此反复。</p>
<p><strong>异步编程</strong>：异步特别适用于大多数 IO 密集型的应用程序</p>
<ul>
<li>回调函数：<code>setTimeout(callback, 1000);</code> | <code>ajax(url, () =&gt; &#123; ... &#125;)</code></li>
<li>事件监听：<code>element.addEventListener(&quot;click&quot;, callback);</code></li>
<li>发布/订阅（观察者模式）：<code>jQuery.subscribe(&quot;done&quot;, f2); //f2向&quot;信号中心&quot;jQuery订阅&quot;done&quot;信号。</code></li>
<li>Promise 对象：<code>var prom = new Promise(fun); prom.then(resolve, reject);</code></li>
<li>Generator 函数：<code>function * gen() &#123; var i = 0; while(i &lt; 10) &#123; i = yield i + 1; &#125; &#125;</code></li>
<li>async/await（推荐）：<code>async function foo() &#123; const result = await doSomething(); &#125;</code></li>
</ul>
<h5 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务 &amp; 微任务"></a>宏任务 &amp; 微任务</h5><p>不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。其中微任务必然是在某个宏任务执行的过程中创建的，例如在执行宏任务时遇到Promise等，会创建微任务（.then()里面的回调），并加入到微任务队列队尾。二者一般所使用的方法如下：</p>
<p><strong>宏任务</strong>：主代码块、setTimeout、setInterval等</p>
<p><strong>微任务</strong>：Promise、process.nextTick等</p>
<p><strong>执行机制</strong></p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/" data-id="cl3jwbhvq000faw5jc2tu6rhr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS事件循环" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time datetime="2022-05-21T11:27:25.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">JS事件循环</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h4><p><strong>定义</strong></p>
<ul>
<li>进程是 CPU <strong>资源分配</strong>的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
</ul>
<p>浏览器是多进程的，主要包含：Browser进程、GPU进程、Renderer进程、Plugin进程等。其中，Browser进程是浏览器的主进程，只有一个；而 Renderer进程 则默认每个Tab页面都有一个，互不影响。</p>
<p>一般说 <strong>JavaScript是单线程语言</strong>，原因主要是由于<strong>GUI渲染线程与JS引擎线程是互斥的（避免 DOM 操作的冲突）</strong>。即在 Renderer进程 中，只能运行其中一个线程，而不能多个线程同时运行。Renderer进程是多线程的，主要线程如下：</p>
<ul>
<li>GUI渲染线程：主要负责渲染浏览器界面</li>
<li>JS引擎线程：主要负责解析Javascript脚本</li>
<li>事件触发线程：主要负责异步事件回调</li>
<li>定时触发器线程：主要负责处理<code>setInterval</code>与<code>setTimeout</code></li>
<li>异步http请求线程：主要负责处理<code>XMLHttpRequest</code>请求</li>
</ul>
<p>基于上述原因，当JS引擎执行大量计算，时间过长阻塞页面的渲染，就会导致页面卡顿，俗称<strong>JS阻塞页面加载</strong></p>
<p><strong>解决方法</strong>：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"><strong>Web Workers</strong></a> 通过调用work构造函数可以创建一个新的子线程来单独处理传入的JS脚本</p>
<h4 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h4><p>Javascript是一门<strong>单线程</strong>的<strong>非阻塞</strong>的脚本语言。单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的<strong>同步任务</strong>。而非阻塞则是当代码需要进行一项<strong>异步任务</strong>（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>
<p><strong>事件循环运行机制</strong></p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li>
<li>当遇到异步任务时，该异步任务进入等待状态，执行栈继续执行。同时通知事件触发线程：当触发该事件时（或该异步操作响应返回时），向任务队列插入一个事件消息</li>
<li>当事件触发或响应返回时，线程向任务队列插入该事件消息（包含消息及回调）；</li>
<li>当执行栈内同步任务执行完毕（空闲：执行栈清空）后，主线程从任务队列取出一个事件消息，其对应异步任务进入执行栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈；</li>
<li>主线程不断重复上面的第4步，称为事件循环(Event Loop)。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" data-id="cl3jwbhvk0009aw5jh411hu7c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2022-05-21T11:24:05.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E7%BC%93%E5%AD%98/">JS缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>http缓存（又称浏览器缓存）</strong>其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。在介绍 http缓存 的时候，我们习惯将缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>两种。两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。</p>
<p><img src="/Users/fjp_xiaoye999/Desktop/FJP/%E5%B7%A5%E4%BD%9C/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png"></p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>第一次请求时，服务器把资源的过期时间通过响应头中的<code>Expires</code>和<code>Cache-Control</code>两个字段告诉浏览器，之后再请求这个资源的话，会判断有没有过期，没有过期就直接拿来用，不向服务器发起请求，这就是强缓存。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>强缓存的弊端就是缓存过期之后，不管资源有没有变化，都会重新发起请求，重新获取资源。而<strong>协商缓存</strong>就是在强缓存过期的情况下，再走协商缓存的流程，判断文件有没有更新。</p>
<p>第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加 <code>Last-Modified</code> 字段，告诉浏览器该资源的最后修改时间；然后浏览器再次请求的时候就把这个时间再通过另一个字段<code>If-Modified-Since</code>，发送给服务器；服务器再把这两个字段的时间对比，如果是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用即可；如果对比不一样说明资源有更新，就返回状态码200和新的资源。</p>
<p><strong>比对策略</strong></p>
<ul>
<li><p><code>Last-Modified</code>/<code>If-Modified-Since</code>：对比文件最后修改时间</p>
</li>
<li><p><code>ETag</code>/<code>If-None-Match</code>：对比文件内容标识</p>
<p>PS：Last-Modified 和 ETag 的区别：</p>
<ul>
<li><code>Etag</code> 感知文件精准度要高于 <code>Last-Modified</code></li>
<li>同时使用时，服务器校验优先级 <code>Etag</code>/<code>If-None-Match</code></li>
<li><code>Last-Modified</code> 性能上要优于 <code>Etag</code>，因为 <code>Etag</code> 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 <code>Last-Modified</code>，只能作为补充和强化</li>
</ul>
</li>
</ul>
<p><strong>优先级</strong>：强制缓存的优先级高于协商缓存（<code>Pragma</code> &gt; <code>Cache-Control</code> &gt; <code>Expires</code> &gt; <code>ETag</code> &gt; <code>Last-Modified</code>）</p>
<p><strong>方案</strong>：协商缓存一般存储：<code>HTML</code>；强缓存一般存储：<code>css</code>, <code>image</code>, <code>js</code>，文件名带上 <code>hash</code></p>
<hr>
<h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>常见的轻量浏览器存储技术包括<code>Cookie</code>和<code>WebStorage</code>。</p>
<table>
    <tbody align="center">
    <tr>
      <th>特性</th>
      <th>Cookie</th>
      <th>sessionStorage</th>
      <th>localStorage</th>
    </tr>
    <tr>
      <td>数据生命期</td>
      <td>生成时会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效</td>
      <td>页面会话期间可用</td>
      <td>除非数据被清除，否则一直存在</td>
    </tr>
    <tr>
      <td>数据存放大小</td>
      <td>4K左右</td>
      <td colspan="2">一般5M或更大</td>
    </tr>
    <tr>
      <td>与服务器通信</td>
      <td>由对服务器的请求来传递，每次都会携带在HTTP请求头中，如果使用cookie保存过多的数据会带来性能问题</td>
      <td colspan="2">数据不是由每个服务器请求传递的，而且只有在请求时使用数据，不参与和服务器的通信</td>
    </tr>
    <tr>
      <td>易用性</td>
      <td>Cookie需要自己封装：setCookie & getCookie</td>
      <td colspan="2">可以用原生接口，也可再次封装对Object和Array有更好的支持</td>
    </tr>
    <tr>
      <td>共同点</td>
      <td colspan="3">都是保存在浏览器端，和服务器端的session机制不同</td>
    </tr>
  </tbody>
</table>


<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。每个 Cookie 都会绑定单一的域名，无法在别的域名下获取使用，换言之，Cookie 不可跨域。</p>
<p>Cookie 主要用于以下三个方面：会话状态管理、个性化设置、浏览器行为跟踪</p>
<p>Cookie 的生命周期可以通过两种方式定义：</p>
<ul>
<li>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。</li>
<li>持久性 Cookie 的生命周期取决于过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）指定的一段时间。</li>
</ul>
<p>有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和<code>HttpOnly</code> 属性</p>
<p>PS：<strong>session</strong> 是另一种记录服务器和客户端会话状态的机制。session 是基于 cookie 实现的，与 cookie 储存在浏览器端不同，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中。</p>
<p><strong>Cookie 和 Session 的区别</strong></p>
<ul>
<li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的；Cookie 是存储在客户端的。</li>
<li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串；Session 可以存任意数据类型。</li>
<li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能；Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li>
<li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K；Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
<p><strong>session 储存 &amp; 同步</strong></p>
<ul>
<li>session共享：将 session 提取出来，集中存放。</li>
<li>token令牌（推荐）：服务器不需要进行存储，服务可以通过解析 token 里面的信息来验证有效性。</li>
</ul>
<h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><p>由于 Cookie 存储机制有很多缺点，HTML5中重新提供了一种在客户端本地保存数据的功能，即<strong>Web Storage</strong>，使浏览器能以一种比使用 Cookie 更直观的方式存储键/值对。Web Storage 包含如下两种机制：</p>
<ul>
<li><code>sessionStorage</code> （临时保存）为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li>
<li><code>localStorage</code> （永久保存）同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li>
</ul>
<p>这两种机制是通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>Window.sessionStorage</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>Window.localStorage</code></a> 属性使用。应该注意，存储在 <code>sessionStorage</code> 或 <code>localStorage</code> 中的数据<strong>特定于页面的协议</strong>，也就是说，不同源的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象相互隔离。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象语法：<code>setItem(&#39;key&#39;, &#39;value&#39;)</code>、<code>getItem(&#39;key&#39;)</code>、<code>removeItem(&#39;key&#39;)</code>、<code>clear()</code></p>
<p>参照：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904034181070861">Cookie、Session、Token、JWT</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E7%BC%93%E5%AD%98/" data-id="cl3jwbhw0000paw5j97wlc716" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E7%BB%A7%E6%89%BF/" class="article-date">
  <time datetime="2022-05-21T11:23:36.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E7%BB%A7%E6%89%BF/">JS继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以使得子类别具有父类的各种方法和属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Hello world&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;BBB&#x27;</span>,<span class="string">&#x27;CCC&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Users/fjp_xiaoye999/Desktop/FJP/%E5%B7%A5%E4%BD%9C/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%BB%A7%E6%89%BF.png"></p>
<p><strong>方式一：原型链继承（★★）</strong></p>
<p>特点：让新实例的原型等于父类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>无法实现多继承，继承单一</li>
<li>来自原型对象的所有属性被所有实例共享</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<p><strong>方式二：构造函数继承（★★）</strong></p>
<p>特点：在子类构造函数中调用父类构造函数，即使用call() /apply()的方法以新创建的对象为上下文执行函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">age</span>)&#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ol>
<p><strong>方式三：组合继承（★★★★）</strong></p>
<p>特点：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name);<span class="comment">// 第二次调用 Parent()</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 第一次调用 Parent()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>; <span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<p><strong>方式四：原型式继承（★★）</strong></p>
<p>特点：**<code>Object.create()</code>**方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="keyword">new</span> <span class="title class_">Parent</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create()方法实现方式如下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">parent</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = parent;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>来自原型对象的所有属性被所有实例共享</li>
</ol>
<p><strong>方式五：寄生式继承（★★）</strong></p>
<p>特点：在原型式继承的基础上再进行增强。即创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="keyword">new</span> <span class="title class_">Parent</span>);</span><br><span class="line">  child.<span class="property">getFriends</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>来自原型对象的所有属性被所有实例共享</li>
</ol>
<p><strong>方式六：寄生组合式继承（★★★★★）</strong></p>
<p>特点：基于组合继承的原理，不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name); <span class="comment">// 仅一次调用 Parent()</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">Parent, Child</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>; <span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent</span>, <span class="title class_">Child</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式七：ES6 class-extends继承（★★★★★）</strong></p>
<p>特点：ES6 寄生组合继承方式的语法糖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>()&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Hello world&#x27;</span>;</span><br><span class="line">  	<span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;BBB&#x27;</span>,<span class="string">&#x27;CCC&#x27;</span>];  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E7%BB%A7%E6%89%BF/" data-id="cl3jwbhvx000oaw5j9k0qgmqe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS跨域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E8%B7%A8%E5%9F%9F/" class="article-date">
  <time datetime="2022-05-21T11:21:06.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E8%B7%A8%E5%9F%9F/">JS跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能。所谓同源是指”协议+域名+端口”三者相同，当协议、域名、端口号中任意一个不相同时，都算作不同源，即便两个不同的域名指向同一个ip地址，也非同源。不同源之间相互请求资源，就算作“跨域”。<code>XMLHttpRequest</code> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a> 遵循<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>。</p>
<blockquote>
<p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</p>
</blockquote>
<p>有多种方式解决跨域问题，常见的有：代理（常用）、CORS（常用）、JSONP</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a><strong>代理</strong></h4><p>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理(proxy)服务器，需要做以下几个步骤：接受客户端请求、将请求转发给服务器、拿到服务器响应数据、将响应转发给客户端。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue 的开发服务器代理配置: vue.config.js</span></span><br><span class="line"><span class="comment">// origin: http://localhost:8080</span></span><br><span class="line"><span class="comment">// proxy服务器: http://localhost:8080</span></span><br><span class="line"><span class="comment">// target服务器: http://dev.server.com</span></span><br><span class="line"><span class="comment">// 请求URL: http://localhost:8080/api/products</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;	<span class="comment">// 配置开发服务器</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123;		<span class="comment">// 配置代理</span></span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123; <span class="comment">// 若请求路径以 /api 开头</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://dev.server.com&quot;</span>, <span class="comment">// 将其转发到 http://dev.server.com</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>CORS（Cross-Origin Resource Sharing，跨源资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它 origin，使得浏览器允许这些 origin 访问加载自己的资源。针对不同的请求，CORS 规定了三种不同的交互模式，分别是：简单请求、需要预检的请求、附带身份凭证的请求。 HTTP 头核心： <code>Access-Control-Allow-Origin</code> </p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>条件判定</th>
</tr>
</thead>
<tbody><tr>
<td>简单请求</td>
<td>1. 请求方法属于下面的一种：<code>get</code>、<code>post</code>、<code>head</code><br>2. 请求头仅包含安全的字段：<br>例如：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code>等<br>3. 请求头如果包含<code>Content-Type</code>，仅限下面的值之一：<br><code>text/plain</code></td>
</tr>
<tr>
<td>预检请求</td>
<td>HTTP 请求头不满足简单请求规则，比如<code>&#39;content-type&#39;: &#39;application/json&#39;</code></td>
</tr>
</tbody></table>
<p><strong>简单请求</strong></p>
<ol>
<li><strong>请求头中会自动添加<code>Origin</code>字段表明该请求来源</strong></li>
<li><strong>服务器响应头中应包含<code>Access-Control-Allow-Origin</code>字段</strong><ul>
<li>字段值为 <code>*</code> 表示该资源可以被 <strong>任意</strong> 外域访问</li>
<li>字段子为具体的源表示该资源可以被 <strong>指定</strong> 外域访问</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端请求 Origin</span></span><br><span class="line"><span class="variable constant_">GET</span> /api/products/ <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="attr">http</span>:<span class="comment">//dev.server.com</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line">...</span><br><span class="line"><span class="title class_">Referer</span>: <span class="attr">http</span>:<span class="comment">//localhost:8080/index.html</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//localhost:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器响应 Access-Control-Allow-Origin</span></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">21</span> <span class="title class_">Apr</span> <span class="number">2020</span> <span class="number">08</span>:<span class="number">03</span>:<span class="number">35</span> <span class="variable constant_">GMT</span></span><br><span class="line">...</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>预检请求</strong></p>
<p>与前述简单请求不同，“需预检的请求”要求必须首先使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p>
<ol>
<li><p><strong>浏览器发送预检请求，询问服务器是否允许</strong></p>
<ul>
<li>请求方法为<code>OPTIONS</code></li>
<li>请求头中包含：<code>Origin</code>、<code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Headers</code></li>
<li>不包含请求体</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> /api/products <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: <span class="attr">http</span>:<span class="comment">//dev.server.com</span></span><br><span class="line">...</span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//localhost:8080</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: <span class="variable constant_">POST</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: a, b, content-type</span><br></pre></td></tr></table></figure></li>
<li><p><strong>服务器允许</strong></p>
<ul>
<li>正常响应，没有响应体</li>
<li>响应头中包含：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>、<code>Access-Control-Max-Age</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">21</span> <span class="title class_">Apr</span> <span class="number">2020</span> <span class="number">08</span>:<span class="number">03</span>:<span class="number">35</span> <span class="variable constant_">GMT</span></span><br><span class="line">...</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//localhost:8080</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">POST</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: a, b, content-type</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">86400</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>浏览器发送真实请求</strong></p>
</li>
<li><p><strong>服务器完成真实的响应</strong></p>
</li>
</ol>
<p>PS：<strong>附带身份凭证的请求</strong>：默认情况下，对于跨源 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 的某个特殊标志位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>当一个请求需要附带身份凭证时，无论它是简单请求，还是预检请求，都会在请求头中添加<code>cookie</code>字段。而服务器响应时，必须在响应头中添加：<code>Access-Control-Allow-Credentials: true</code>，否则浏览器将不会把响应内容返回给请求的发送者。</p>
<p>PS：在响应附带身份凭证的请求时，服务器不能将 <code>Access-Control-Allow-Origin</code> 、 <code>Access-Control-Allow-Headers</code> 、 <code>Access-Control-Allow-Methods</code> 的值设为通配符“<code>*</code>”，而应将其设置为具体的值。</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h4><p>HTML 中有三个标签是允许跨域加载资源：<code>&lt;img src=XXX&gt;</code>、<code>&lt;link href=XXX&gt;</code>、<code>&lt;script src=XXX&gt;</code></p>
<p>JSONP的原理</p>
<ol>
<li><p>当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。</p>
<p>PS：该请求应该包含需要传输的 <strong>参数</strong> 和处理响应的 <strong>回调函数</strong>。</p>
</li>
<li><p>服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端。</p>
<p>PS：响应实际上就是 <strong>回调函数的调用</strong>，响应真正内容实际上是回调函数的 <strong>参数</strong></p>
</li>
<li><p>浏览器处理script元素中的JS代码</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">客户端：index.html</span><br><span class="line">...</span><br><span class="line">&lt;script src=&quot;http://localhost:3000/api/products?wd=xiaoye&amp;callback=show&quot;&gt;&lt;/script&gt;</span><br><span class="line">...</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function show(data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 服务器端：server.js</span><br><span class="line">let express = require(&#x27;express&#x27;)</span><br><span class="line"></span><br><span class="line">let app = express()</span><br><span class="line">app.get(&#x27;/api/products&#x27;, function(req, res) &#123;</span><br><span class="line">  let &#123; wd, callback &#125; = req.query</span><br><span class="line">  console.log(wd) // xiaoye</span><br><span class="line">  console.log(callback) // show</span><br><span class="line">  res.end(`$&#123;callback&#125;(&#x27;响应数据&#x27;)`) // 返回：show(&#x27;响应数据&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E8%B7%A8%E5%9F%9F/" data-id="cl3jwbhw0000qaw5j0x371wbq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-ES6新增特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2022-05-21T11:12:47.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/">JS-ES6新增特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ES6新增特性"><a href="#ES6新增特性" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h3><p><strong>表达式</strong></p>
<ul>
<li>声明：<code>let</code> &amp; <code>const</code></li>
<li>解构赋值：字符串解构、对象解构、数组解构 ……</li>
</ul>
<p><strong>内置对象</strong></p>
<ul>
<li>字符串扩展：模版字符串</li>
<li>函数扩展：参数默认值、rest/spread参数(<code>...</code>)、箭头函数(<code>=&gt;</code>)</li>
<li>数值扩展、对象扩展、数组扩展、正则扩展 ……</li>
<li><code>Symbol</code>-独一无二的值、<code>Set</code>-集合（成员值都是唯一且没有重复的值）、<code>Map</code>-映射（类似于对象，成员键可以是任何类型的值）、<code>Proxy</code>-修改某些操作的默认行为、<code>Reflect</code>-保持<code>Object</code>方法的默认行为</li>
</ul>
<p><strong>语句与运算</strong>：<code>Class</code></p>
<p><strong>异步编程</strong>：<code>Promise</code>-异步对象、<code>Generator</code>-生成器对象、<code>Async</code>函数</p>
<p><strong>模块Module</strong>：<code>import</code> &amp; <code>export</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; x, y &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;; <span class="comment">//对象解构</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好，&#x27;</span> + $&#123;name&#125;); <span class="comment">//模版字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span>, ...rest</span>) &#123;&#125; <span class="comment">//参数默认值 + rest参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="title class_">Symbol</span>(str)</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr) <span class="comment">//集合</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Map</span>(arr) <span class="comment">//映射</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler) <span class="comment">//Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123; <span class="comment">//子类Child继承自Person</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>) &#123; <span class="comment">//构造函数</span></span><br><span class="line">    <span class="variable language_">super</span>(name, sex); <span class="comment">//调用父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;) <span class="comment">//Promise</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title class_">Func</span>() &#123;<span class="keyword">yield</span> gene&#125; <span class="comment">//Generator</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="comment">//async await</span></span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)))</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; age, name, sex &#125; <span class="comment">//按需导出</span></span><br><span class="line"><span class="keyword">import</span> &#123; age, name, sex &#125; <span class="keyword">from</span> <span class="string">&quot;person&quot;</span> <span class="comment">//按需导入</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/" data-id="cl3jwbhvb0001aw5jax3o0gpv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS深拷贝与浅拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/21/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time datetime="2022-05-21T11:12:11.000Z" itemprop="datePublished">2022-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/21/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/">JS深拷贝与浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="浅拷贝-amp-深拷贝"><a href="#浅拷贝-amp-深拷贝" class="headerlink" title="浅拷贝 &amp; 深拷贝"></a>浅拷贝 &amp; 深拷贝</h3><p><strong>浅拷贝</strong>是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<strong>深拷贝</strong>是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。</p>
<p>总而言之，浅拷贝只复制指向某个对象的指针，而不复制对象本身，<strong>新旧对象还是共享同一块内存</strong>。但深拷贝会另外创造一个一模一样的对象，<strong>新对象跟原对象不共享内存</strong>，修改新对象不会改到原对象。</p>
<p><strong>浅拷贝</strong></p>
<ul>
<li><code>Object.assign()</code>：将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</li>
<li><code>...展开运算符</code>：将可迭代对象转为用逗号分隔的参数序列，与<code>Object.assign()</code>功能类似。</li>
<li><code>Array.from()</code> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</li>
<li><code>concat()</code>  | <code>slice()</code> 方法都可以返回一个新的数组对象（浅拷贝），不会改变原始数组。</li>
<li>函数库lodash的<code>_.clone</code>方法</li>
</ul>
<p><strong>深拷贝</strong></p>
<ul>
<li><code>JSON.parse(JSON.stringify())</code>：可以实现数组或对象深拷贝，但不能处理函数和正则</li>
<li><code>jQuery.extend()</code>：<code>$.extend(deepCopy, target, object1, [objectN]) </code></li>
<li>函数库lodash的<code>_.cloneDeep</code>方法</li>
<li>手写：递归算法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaodanye.github.io/2022/05/21/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="cl3jwbhvu000kaw5jfvfx5qnu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/24/Vue%E8%99%9A%E6%8B%9FDOM-diff%E7%AE%97%E6%B3%95/">Vue虚拟DOM-diff算法</a>
          </li>
        
          <li>
            <a href="/2022/05/24/Vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6/">Vue父子组件</a>
          </li>
        
          <li>
            <a href="/2022/05/24/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/">Vue双向绑定</a>
          </li>
        
          <li>
            <a href="/2022/05/24/Vue-SPA/">Vue-SPA</a>
          </li>
        
          <li>
            <a href="/2022/05/24/Vue-computed-methods-watch/">Vue-computed_methods_watch</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Xiaodanye<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>